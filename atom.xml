<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wupengli Blog</title>
  
  <subtitle>我分享，我快乐</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-09T15:34:09.947Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>吴鹏丽</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解决 stylus 变量每次引入的痛点</title>
    <link href="http://yoursite.com/2018/01/09/Vue/%E8%A7%A3%E5%86%B3%20stylus%20%E5%8F%98%E9%87%8F%E9%9C%80%E8%A6%81%E5%9C%A8%E6%AF%8F%E4%B8%80%E4%B8%AA%20vue%20%E7%BB%84%E4%BB%B6%E5%BC%95%E5%85%A5%E7%9A%84%E7%97%9B%E7%82%B9/"/>
    <id>http://yoursite.com/2018/01/09/Vue/解决 stylus 变量需要在每一个 vue 组件引入的痛点/</id>
    <published>2018-01-09T14:56:56.000Z</published>
    <updated>2018-01-09T15:34:09.947Z</updated>
    
    <content type="html"><![CDATA[<p>很多情况，我们在会定义一个存放全局变量的一个 stylus 文件，用来存放全局通用的一些常量，如果写过 vue 组件的人应该很清楚，基本每次需要用到该文件的变量的时候都需要重复的使用 <code>@import</code> 进行重新引入的操作，这样难免有些烦，为什么不可以一次性的导入，全局使用呢？ 经过调研，最终实现方式是非常的简单的就实现了。具体的方法见下面:</p><p>在 build/utils.js 的 generateLoaders 方法下做如下修改</p><p><img src="/img/stylus.png" alt=""></p><p>那么当使用 less 的时候呢？</p><p>想想是不是也有类似上面的方式实现一次性的导入全局变量的参数配置，不过本人没有亲试，但是如果不行的话， 还提供了一种笨的方式, <a href="https://zhuanlan.zhihu.com/p/27439821">点击这里</a></p><p>推荐阅读：<br><a href="https://github.com/lavas-project/vue-style-variables-loader">vue-style-variables-loader</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多情况，我们在会定义一个存放全局变量的一个 stylus 文件，用来存放全局通用的一些常量，如果写过 vue 组件的人应该很清楚，基本每次需要用到该文件的变量的时候都需要重复的使用 &lt;code&gt;@import&lt;/code&gt; 进行重新引入的操作，这样难免有些烦，为什么不可以
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>gitlab、coding 之间项目迁移的那些事</title>
    <link href="http://yoursite.com/2018/01/09/gitlab%E3%80%81coding%20%E4%B9%8B%E9%97%B4%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yoursite.com/2018/01/09/gitlab、coding 之间项目迁移的那些事/</id>
    <published>2018-01-09T14:54:29.000Z</published>
    <updated>2018-01-09T14:59:36.581Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>网站国际化实践心得</title>
    <link href="http://yoursite.com/2018/01/09/%E7%BD%91%E7%AB%99%E5%9B%BD%E9%99%85%E5%8C%96%E5%AE%9E%E8%B7%B5%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2018/01/09/网站国际化实践心得/</id>
    <published>2018-01-09T14:53:32.000Z</published>
    <updated>2018-01-09T15:11:51.735Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端推荐书籍</title>
    <link href="http://yoursite.com/2018/01/08/Tools/%E5%89%8D%E7%AB%AF%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%B1%8D/"/>
    <id>http://yoursite.com/2018/01/08/Tools/前端推荐书籍/</id>
    <published>2018-01-08T15:41:39.000Z</published>
    <updated>2018-01-08T15:52:11.965Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><ol><li><a href="http://iissnan.com/progit/">《Pro Git》</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Git&quot;&gt;&lt;a href=&quot;#Git&quot; class=&quot;headerlink&quot; title=&quot;Git&quot;&gt;&lt;/a&gt;Git&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://iissnan.com/progit/&quot;&gt;《Pro Git》&lt;/a&gt;&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>代码风格指南</title>
    <link href="http://yoursite.com/2018/01/08/CSS/Google%20%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/01/08/CSS/Google 风格指南/</id>
    <published>2018-01-08T13:10:31.000Z</published>
    <updated>2018-01-08T15:07:07.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码风格指南"><a href="#代码风格指南" class="headerlink" title="代码风格指南"></a>代码风格指南</h2><blockquote><p>始终认为拥有良好的代码规范是程序员的必修课，良好的编程习惯是成为优秀程序员的前提。</p></blockquote><p>强烈推荐阅读：<a href="https://github.com/romoo/google-html-css-style-guide/">《google-html-css-style-guide》</a></p><p>如果有兴趣还可以看下：<a href="https://github.com/fex-team/styleguide">《文档与源码编写风格》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码风格指南&quot;&gt;&lt;a href=&quot;#代码风格指南&quot; class=&quot;headerlink&quot; title=&quot;代码风格指南&quot;&gt;&lt;/a&gt;代码风格指南&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;始终认为拥有良好的代码规范是程序员的必修课，良好的编程习惯是成为优秀程序员的前提。
      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>Js读写 excel 文件</title>
    <link href="http://yoursite.com/2017/11/25/Node/Js%E8%AF%BB%E5%86%99%20xlsx%20%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/11/25/Node/Js读写 xlsx 文件/</id>
    <published>2017-11-25T15:56:03.000Z</published>
    <updated>2018-01-09T14:49:48.185Z</updated>
    
    <content type="html"><![CDATA[<p>在 js 的世界中如何操作 excel 文件的读写， 下面是我项目中用到的比较简单的方式实现的 excel 文件的读写操作</p><h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><figure class="highlight coffee"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">xlsx = <span class="built_in">require</span> <span class="string">'xlsx'</span></div><div class="line">fs = <span class="built_in">require</span> <span class="string">'fs'</span></div><div class="line"></div><div class="line">xmlFile = xlsx.readFile(<span class="string">'./translate.xlsx'</span>)</div><div class="line"></div><div class="line">Sheets = xmlFile.Sheets</div><div class="line">SheetNames = xmlFile.SheetNames</div><div class="line">worksheet = Sheets[SheetNames[<span class="number">0</span>]]</div><div class="line"></div><div class="line">json_conversion = xlsx.utils.sheet_to_json(worksheet)</div><div class="line"></div><div class="line">readExcelResult = &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> record <span class="keyword">in</span> json_conversion</div><div class="line">  readExcelResult[record.cn] = record.en <span class="keyword">or</span> <span class="string">''</span>;</div><div class="line"></div><div class="line">fs.writeFile <span class="string">'./trans.json'</span>, JSON.stringify readExcelResult, <span class="string">'utf-8'</span>, <span class="function"><span class="params">(err)</span> =&gt;</span></div><div class="line">  <span class="keyword">if</span>(err)</div><div class="line">    <span class="keyword">throw</span> err</div></pre></td></tr></table></figure><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><figure class="highlight coffee"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">fs = <span class="built_in">require</span> <span class="string">'fs'</span></div><div class="line">xlsx = <span class="built_in">require</span> <span class="string">'better-xlsx'</span></div><div class="line">file = <span class="keyword">new</span> xlsx.File</div><div class="line">sheet = file.addSheet <span class="string">'输出结果'</span></div><div class="line">cn = <span class="built_in">require</span> <span class="string">'../lang/cn.coffee'</span></div><div class="line"></div><div class="line">data = []</div><div class="line"><span class="keyword">for</span> key, value <span class="keyword">of</span> cn</div><div class="line">  data.push [key, value, en[key]]</div><div class="line"></div><div class="line">header = sheet.addRow()</div><div class="line">headers = [<span class="string">'key'</span>, <span class="string">'cn'</span>, <span class="string">'en'</span>]</div><div class="line"></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> headers</div><div class="line">  hc = header.addCell()</div><div class="line">  hc.value = item</div><div class="line"></div><div class="line"><span class="keyword">for</span> rowData, index <span class="keyword">in</span> data</div><div class="line">  row = sheet.addRow()</div><div class="line"></div><div class="line">  <span class="keyword">for</span> cellData, index <span class="keyword">in</span> rowData</div><div class="line">    cell = row.addCell()</div><div class="line">    cell.value = cellData</div><div class="line"></div><div class="line">file</div><div class="line">  .saveAs()</div><div class="line">  .pipe fs.createWriteStream __dirname + <span class="string">'/translate.xlsx'</span></div><div class="line">  .<span class="literal">on</span>(<span class="string">'finish'</span>, <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log <span class="string">'Done.'</span>)</div></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://segmentfault.com/q/1010000002996909">https://segmentfault.com/q/1010000002996909</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 js 的世界中如何操作 excel 文件的读写， 下面是我项目中用到的比较简单的方式实现的 excel 文件的读写操作&lt;/p&gt;
&lt;h3 id=&quot;读操作&quot;&gt;&lt;a href=&quot;#读操作&quot; class=&quot;headerlink&quot; title=&quot;读操作&quot;&gt;&lt;/a&gt;读操作&lt;/h3&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise 必知必会的面试题</title>
    <link href="http://yoursite.com/2017/11/09/ES6/Promise%20%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2017/11/09/ES6/Promise 必知必会的面试题/</id>
    <published>2017-11-09T05:50:00.000Z</published>
    <updated>2017-11-27T13:52:31.948Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 想必大家都十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。</p><p>以下 promise 均指代 Promise 实例，环境是 Node.js。</p><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</div><div class="line">  resolve()</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</div><div class="line">&#125;)</div><div class="line">promise.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">4</div><div class="line">3</div></pre></td></tr></table></figure><p>解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    resolve(<span class="string">'success'</span>)</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div><div class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</div><div class="line"></div><div class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</div><div class="line">&#125;, <span class="number">2000</span>)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">promise1 Promise &#123; &lt;pending&gt; &#125;</div><div class="line">promise2 Promise &#123; &lt;pending&gt; &#125;</div><div class="line">(node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!</div><div class="line">(node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</div><div class="line">promise1 Promise &#123; &apos;success&apos; &#125;</div><div class="line">promise2 Promise &#123;</div><div class="line">  &lt;rejected&gt; Error: error!!!</div><div class="line">    at promise.then (...)</div><div class="line">    at &lt;anonymous&gt; &#125;</div></pre></td></tr></table></figure><p>解释：promise 有 3 种状态：pending、fulfilled 或 rejected。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。</p><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const promise = new Promise((resolve, reject) =&gt; &#123;</div><div class="line">  resolve(&apos;success1&apos;)</div><div class="line">  reject(&apos;error&apos;)</div><div class="line">  resolve(&apos;success2&apos;)</div><div class="line">&#125;)</div><div class="line"></div><div class="line">promise</div><div class="line">  .then((res) =&gt; &#123;</div><div class="line">    console.log(&apos;then: &apos;, res)</div><div class="line">  &#125;)</div><div class="line">  .catch((err) =&gt; &#123;</div><div class="line">    console.log(&apos;catch: &apos;, err)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">then: success1</div></pre></td></tr></table></figure><p>解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。</p><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</div><div class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span></div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">3</span></div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(res)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div></pre></td></tr></table></figure><p>解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。</p><h2 id="题目五"><a href="#题目五" class="headerlink" title="题目五"></a>题目五</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</div><div class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'once'</span>)</div><div class="line">    resolve(<span class="string">'success'</span>)</div><div class="line">  &#125;, <span class="number">1000</span>)</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</div><div class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</div><div class="line">&#125;)</div><div class="line">promise.then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(res, <span class="built_in">Date</span>.now() - start)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">once</div><div class="line">success 1005</div><div class="line">success 1007</div></pre></td></tr></table></figure><p>解释：promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。</p><h2 id="题目六"><a href="#题目六" class="headerlink" title="题目六"></a>题目六</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">then: Error: error!!!</div><div class="line">    at Promise.resolve.then (...)</div><div class="line">    at ...</div></pre></td></tr></table></figure><p>解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获，需要改成其中一种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>))</div><div class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</div></pre></td></tr></table></figure><p>因为返回任意一个非 promise 的值都会被包裹成 promise 对象，即 return new Error(‘error!!!’) 等价于 return Promise.resolve(new Error(‘error!!!’))。</p><h2 id="题目七"><a href="#题目七" class="headerlink" title="题目七"></a>题目七</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve()</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> promise</div><div class="line">  &#125;)</div><div class="line">promise.catch(<span class="built_in">console</span>.error)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">TypeError: Chaining cycle detected for promise #&lt;Promise&gt;</div><div class="line">    at &lt;anonymous&gt;</div><div class="line">    at process._tickCallback (internal/process/next_tick.js:188:7)</div><div class="line">    at Function.Module.runMain (module.js:667:11)</div><div class="line">    at startup (bootstrap_node.js:187:16)</div><div class="line">    at bootstrap_node.js:607:3</div></pre></td></tr></table></figure><p>解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环。类似于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">process.nextTick(<span class="function"><span class="keyword">function</span> <span class="title">tick</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'tick'</span>)</div><div class="line">  process.nextTick(tick)</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h2 id="题目八"><a href="#题目八" class="headerlink" title="题目八"></a>题目八</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</div><div class="line">  .then(<span class="number">2</span>)</div><div class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</div><div class="line">  .then(<span class="built_in">console</span>.log)</div></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div></pre></td></tr></table></figure></p><p>解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。</p><h2 id="题目九"><a href="#题目九" class="headerlink" title="题目九"></a>题目九</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">success</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'fail1: '</span>, e)</div><div class="line">  &#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'fail2: '</span>, e)</div><div class="line">  &#125;)</div><div class="line"><span class="string">``</span><span class="string">`text</div><div class="line"></div><div class="line">运行结果：</div><div class="line"></div><div class="line">`</span><span class="string">``</span>text</div><div class="line">fail2: <span class="built_in">Error</span>: error</div><div class="line">    at success (...)</div><div class="line">    at ...</div></pre></td></tr></table></figure><p>解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。当然以下代码也可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">success1</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail1</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'fail1: '</span>, e)</div><div class="line">  &#125;)</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">success2</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">fail2</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.error(<span class="string">'fail2: '</span>, e)</div><div class="line">  &#125;)</div></pre></td></tr></table></figure><h2 id="题目十"><a href="#题目十" class="headerlink" title="题目十"></a>题目十</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">Promise</span>.resolve()</div><div class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>)</div><div class="line">  &#125;)</div><div class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>)</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</div></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">end</div><div class="line">nextTick</div><div class="line">then</div><div class="line">setImmediate</div></pre></td></tr></table></figure><p>解释：process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Promise 想必大家都十分熟悉，想想就那么几个 api，可是你真的了解 Promise 吗？本文根据 Promise 的一些知识点总结了十道题，看看你能做对几道。&lt;/p&gt;
&lt;p&gt;以下 promise 均指代 Promise 实例，环境是 Node.js。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>gitlab使用</title>
    <link href="http://yoursite.com/2017/11/07/Tools/gitlab%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2017/11/07/Tools/gitlab的使用/</id>
    <published>2017-11-07T06:01:16.000Z</published>
    <updated>2018-01-09T14:11:47.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gitlab-push-如何自动关闭-issues"><a href="#gitlab-push-如何自动关闭-issues" class="headerlink" title="gitlab push 如何自动关闭 issues"></a>gitlab push 如何自动关闭 issues</h2><p>在Github中,我们可以通过git push的提交日志信息,自动关闭相关的issue, 比如 git push -m ‘closed #123’, 将自动关闭Issue #123.</p><p>其实Gitlab中也存在类似的功能, 在Gitlab默认的配置文件 /etc/gitlab/gitlab.rb 中, <strong>issue_closing_pattern</strong> 通过模式匹配用户的提交日志, 如果查找到相关信息,将自动关闭日志中的 Issue. issue_closing_pattern 的默认设置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">issue_closing_pattern: &apos;((?:[Cc]los(?:e[sd]|ing)|[Ff]ix(?:e[sd]|ing)?) +(?:(?:issues? +)?%&#123;issue_ref&#125;(?:(?:, *| +and +)?))+)&apos;</div></pre></td></tr></table></figure><p>比如一个用户的提交日志如下:</p><p> <code>git commit -m &quot;bugfix for something (Fix #10, Fixes #15, #20, Closes group/project#30, Closed #50). And create new bug #100&quot;</code></p><p>Gitlat将自动关闭 Issue #10, #15, #20, #50, 以及跨group跨project的Issue #30; 但并不会关闭 Issue #100, 因为#100不能模式匹配issue_closing_pattern.</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>如果仅仅是提交了代码，但是还没有被合并到 <strong>master</strong> 分支的情况下，也是无法关闭 issues 的， 目标分支的名字必须是 <strong>master</strong> 分支</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;gitlab-push-如何自动关闭-issues&quot;&gt;&lt;a href=&quot;#gitlab-push-如何自动关闭-issues&quot; class=&quot;headerlink&quot; title=&quot;gitlab push 如何自动关闭 issues&quot;&gt;&lt;/a&gt;gitlab push
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>hexo入门教程</title>
    <link href="http://yoursite.com/2017/09/11/Hexo/hexo%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/09/11/Hexo/hexo入门教程/</id>
    <published>2017-09-10T16:42:35.704Z</published>
    <updated>2017-09-10T16:42:35.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h2><p>简单的理解，它可以帮我们快速的生成博客，方便程序员做技术总结和技术分享的一个工具而已，那么，就让我们开始hexo的快乐之旅吧…</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo init &lt;folder&gt;</div><div class="line">$ cd &lt;folder&gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure><p>安装完成后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── _config.yml</div><div class="line">├── package.json</div><div class="line">├── scaffolds</div><div class="line">├── source</div><div class="line">|   ├── _drafts</div><div class="line">|   └── _posts</div><div class="line">└── themes</div></pre></td></tr></table></figure></p><p>启动服务器进行本地预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s</div></pre></td></tr></table></figure><p>在浏览器中打开<a href="http://localhost:4000，成功的话即可看到博客页面，至此安装就完成了。">http://localhost:4000，成功的话即可看到博客页面，至此安装就完成了。</a></p><p>具体的文件的用途请访问：[hexo官网][<a href="https://hexo.io/zh-cn/docs/setup.html">https://hexo.io/zh-cn/docs/setup.html</a>]</p><h2 id="运用NexT主题搭建自己的博客"><a href="#运用NexT主题搭建自己的博客" class="headerlink" title="运用NexT主题搭建自己的博客"></a>运用NexT主题搭建自己的博客</h2><p>下载主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd your-hexo-site</div><div class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure></p><p>启用主题<br>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next</div></pre></td></tr></table></figure></p><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。<br>验证主题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo s --debug</div></pre></td></tr></table></figure></p><p>当你看到站点的外观与下图所示类似时即说明你已成功安装 NexT 主题。这是 NexT 默认的 Scheme —— Muse<br><img src="http://theme-next.iissnan.com/uploads/five-minutes-setup/validation-default-scheme-mac.png" alt=""></p><p>更多关于NextT主题的设置参考官网[Next][<a href="http://theme-next.iissnan.com/getting-started.html">http://theme-next.iissnan.com/getting-started.html</a>]</p><h2 id="如何灵活的运用hexo主题"><a href="#如何灵活的运用hexo主题" class="headerlink" title="如何灵活的运用hexo主题"></a>如何灵活的运用hexo主题</h2><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ hexo n ‘name’  新建</div><div class="line">$ hexo g         跟新</div><div class="line">$ hexo s         预览</div><div class="line">$ hexo d         同步</div><div class="line">$ hexo clean     清除缓存文件（db.json）和已生成的静态文件(public)</div></pre></td></tr></table></figure><p>在github中新建一个仓库的名字，名字是唯一的。github账户名+github.io</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://用户名:密码@仓库地址</div><div class="line">  branch: master</div><div class="line">  message: push</div></pre></td></tr></table></figure><p>部署到网站上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><h4 id="新建一个页面"><a href="#新建一个页面" class="headerlink" title="新建一个页面"></a>新建一个页面</h4><p>首先，我们通过hexo n “name”命令来新建一个页面，在source/_posts目录下找到刚才新建的name.md文件，用记事本或者sublime text打开。<br>我们看到默认的页面是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: name</div><div class="line">date: 2014-08-05 11:15:00 </div><div class="line">tags: </div><div class="line">---</div></pre></td></tr></table></figure></p><p>可以编辑标题、日期、标签和内容，但是没有分类的选项。我们可以手动加入<code>categories</code>:项，或者打开<code>scaffolds/post.md</code>文件，在tages:上面加入<code>categories:</code>,保存后，重新执行<code>hexo n &#39;name&#39;</code>命令，会发现新建的页面里有<code>categories:</code>项了。<br>scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。</p><h4 id="设置分类列表"><a href="#设置分类列表" class="headerlink" title="设置分类列表"></a>设置分类列表</h4><p>在我们编辑文章的时候，直接在categories:项填写属于哪个分类，但如果分类是中文的时候，路径也会包含中文。<br>比如分类我们设置的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">categories: 编程</div></pre></td></tr></table></figure></p><p>那在生成页面后，分类列表就会出现编程这个选项，他的访问路径是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*/categories/编程</div></pre></td></tr></table></figure></p><p>如果我们想要把路径名和分类名分别设置，需要怎么办呢？<br>打开根目录下的配置文件<code>_config.yml</code>，找到如下位置做更改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Category &amp; Tag</div><div class="line">default_category: uncategorized</div><div class="line">category_map:</div><div class="line">编程: programming</div><div class="line">生活: life</div><div class="line">其他: other</div><div class="line">tag_map:</div></pre></td></tr></table></figure></p><p>在这里<code>category_map:</code>是设置分类的地方，每行一个分类，冒号前面是分类名称，后面是访问路径。<br>可以提前在这里设置好一些分类，当编辑的文章填写了对应的分类名时，就会自动的按照对应的路径来访问。</p><h4 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a>设置标签</h4><p>生成标签主页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new page &quot;tags&quot;</div></pre></td></tr></table></figure></p><p>这个命令只是生成tags的主页面，并没有生成标签，这个要自己去设置，具体做法如下：<br>在编辑文章的时候，tags:后面是设置标签的地方，如果有多个标签的话，可以用下面两种办法来设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[标签1,标签2,...标签n]</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> tages: </div><div class="line">- 标签1</div><div class="line">- 标签2</div><div class="line">...</div><div class="line">- 标签n</div></pre></td></tr></table></figure><p><font color="red">更加详细的教程参见</font><br>[hexo][<a href="http://www.joryhe.com/2016-05-17-hexoxo-series-for-site-build-basic.html#">http://www.joryhe.com/2016-05-17-hexoxo-series-for-site-build-basic.html#</a>]</p><h4 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h4><h5 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h5><p>在blog目录下的_config.yml配置文件末尾添加以下内容以设置分页参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"># Plugins</div><div class="line">index_generator:</div><div class="line">  per_page: 10 ##首页默认10篇文章标题，如果值为0不分页</div><div class="line"></div><div class="line">archive_generator:</div><div class="line">  per_page: 10 ##归档页面默认10篇文章标题，如果值为0不分页</div><div class="line">  yearly: true ##生成年视图</div><div class="line">  monthly: true ##生成月视图</div><div class="line"></div><div class="line">tag_generator:</div><div class="line">  per_page: 10 ##标签页面默认10篇文章，如果值为0不分页</div><div class="line"></div><div class="line">category_generator: </div><div class="line">  per_page: 10 ##分类页面默认10篇文章，如果值为0不分页</div></pre></td></tr></table></figure></p><h5 id="推荐插件"><a href="#推荐插件" class="headerlink" title="推荐插件"></a>推荐插件</h5><p>hexo-deployer-git<br>用于向GitHub、GitCafe部署静态页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure><p>在blog目录下的_config.yml配置文件末尾设置，配置格式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github用户名:github密码@github.com/wplnancy/wplnancy.github.io.git</div><div class="line">  branch: master</div><div class="line">  message: push</div></pre></td></tr></table></figure></p><p>hexo-generator-feed 用于生成RSS订阅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-feed --save</div></pre></td></tr></table></figure><p>hexo-generator-sitemap 用于生成搜索引擎网站地图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div></pre></td></tr></table></figure><h4 id="Markdown-语法速查表"><a href="#Markdown-语法速查表" class="headerlink" title="Markdown 语法速查表"></a>Markdown 语法速查表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">1 标题与文字格式  </div><div class="line">标题  </div><div class="line"># 这是 H1 &lt;一级标题&gt;  </div><div class="line">## 这是 H2 &lt;二级标题&gt;  </div><div class="line">###### 这是 H6 &lt;六级标题&gt;  </div><div class="line">文字格式  </div><div class="line">**这是文字粗体格式**  </div><div class="line">*这是文字斜体格式*  </div><div class="line">~~在文字上添加删除线~~  </div><div class="line">2 列表  </div><div class="line">无序列表  </div><div class="line">* 项目1  </div><div class="line">* 项目2  </div><div class="line">* 项目3  </div><div class="line">有序列表  </div><div class="line">1. 项目1  </div><div class="line">2. 项目2  </div><div class="line">3. 项目3  </div><div class="line">   * 项目1  </div><div class="line">   * 项目2  </div><div class="line">3 其它  </div><div class="line">图片  </div><div class="line">![图片名称](http://gitcafe.com/image.png)  </div><div class="line">链接  </div><div class="line">[链接名称](http://gitcafe.com)  </div><div class="line">引用  </div><div class="line">&gt; 第一行引用文字  </div><div class="line">&gt; 第二行引用文字  </div><div class="line">水平线  </div><div class="line">***  </div><div class="line">代码  </div><div class="line">`&lt;hello world&gt;`</div></pre></td></tr></table></figure><h4 id="完成hexo自动备份"><a href="#完成hexo自动备份" class="headerlink" title="完成hexo自动备份"></a>完成hexo自动备份</h4><p>我曾经给出过通过Git备份Hexo博客源文件的方式，这种方式虽然能够备份Hexo博客的源文件，但是对于博主这种懒人，每次更新博文都需要输入两三行重复的Git命令真是一件麻烦的事情。况且指不定哪天就搞忘push到github上了。</p><p>####将Hexo目录加入Git仓库</p><p>本脚本需要提前将Hexo加入Git仓库并与Github或者Gitcafe远程仓库绑定之后，才能正常工作。如果你不知道怎么操作，请参考这篇博文：</p><p>备份Hexo博客源文件</p><p>[<a href="https://notes.wanghao.work/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html">https://notes.wanghao.work/2015-07-06-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BDHexo%E5%8D%9A%E5%AE%A2%E6%BA%90%E6%96%87%E4%BB%B6.html</a>]</p><p>####安装shelljs模块</p><p>要实现这个自动备份功能，需要依赖NodeJs的一个shelljs模块,该模块重新包装了child_process,调用系统命令更加的方便。（其实就是因为博主懒( ╯▽╰)）该模块需要安装后使用。</p><p>在命令中键入以下命令，完成shelljs模块的安装：</p><p><code>npm install --save shelljs</code></p><p>####编写自动备份脚本</p><p>待到模块安装完成，在Hexo根目录的scripts文件夹下新建一个js文件，文件名随意取。</p><p>如果没有scripts目录，请新建一个。</p><p>然后在脚本中，写入以下内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'shelljs/global'</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">hexo.on(<span class="string">'deployAfter'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="comment">//当deploy完成后执行备份</span></div><div class="line">run();</div><div class="line">&#125;);</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为："</span> + e.toString());</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">if</span> (!which(<span class="string">'git'</span>)) &#123;</div><div class="line">echo(<span class="string">'Sorry, this script requires git'</span>);</div><div class="line">exit(<span class="number">1</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">echo(<span class="string">"======================Auto Backup Begin==========================="</span>);</div><div class="line">cd(<span class="string">'D:/hexo'</span>);    <span class="comment">//此处修改为Hexo根目录路径</span></div><div class="line"><span class="keyword">if</span> (exec(<span class="string">'git add --all'</span>).code !== <span class="number">0</span>) &#123;</div><div class="line">echo(<span class="string">'Error: Git add failed'</span>);</div><div class="line">exit(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (exec(<span class="string">'git commit -am "Form auto backup script\'s commit"'</span>).code !== <span class="number">0</span>) &#123;</div><div class="line">echo(<span class="string">'Error: Git commit failed'</span>);</div><div class="line">exit(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (exec(<span class="string">'git push origin master'</span>).code !== <span class="number">0</span>) &#123;</div><div class="line">echo(<span class="string">'Error: Git push failed'</span>);</div><div class="line">exit(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line">echo(<span class="string">"==================Auto Backup Complete============================"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中，需要修改第<code>17</code>行的<code>D:/hexo</code>路径为Hexo的根目录路径。（脚本中的路径为博主的Hexo路径）</p><p>如果你的<code>Git</code>远程仓库名称不为<code>origin</code>的话，还需要修改第28行执行的push命令，修改成自己的远程仓库名和相应的分支名。</p><p>保存脚本并退出，然后执行<code>hexo deploy</code>命令，将会得到类似以下结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">INFO  Deploying: git&gt;</div><div class="line">INFO  Clearing .deploy folder...</div><div class="line">INFO  Copying files from public folder...</div><div class="line">[master 3020788] Site updated: 2015-07-06 15:08:06</div><div class="line"> 5 files changed, 160 insertions(+), 58 deletions(-)</div><div class="line">Branch master set up to track remote branch gh-pages from git@github.com:smilexi</div><div class="line">amo/notes.git.</div><div class="line">To git@github.com:smilexiamo/notes.git</div><div class="line">   02adbe4..3020788  master -&gt; gh-pages</div><div class="line">On branch master</div><div class="line">nothing to commit, working directory clean</div><div class="line">Branch master set up to track remote branch gitcafe-pages from git@gitcafe.com:s</div><div class="line">milexiamo/smilexiamo.git.</div><div class="line">To git@gitcafe.com:smilexiamo/smilexiamo.git</div><div class="line">   02adbe4..3020788  master -&gt; gitcafe-pages</div><div class="line">INFO  Deploy done: git</div><div class="line">======================Auto Backup Begin===========================</div><div class="line">[master f044360] Form auto backup script&apos;s commit</div><div class="line"> 2 files changed, 35 insertions(+), 2 deletions(-)</div><div class="line"> rewrite db.json (100%)</div><div class="line">To git@github.com:smilexiamo/hexo.git</div><div class="line">   8f2b4b4..f044360  master -&gt; master</div><div class="line">==================Auto Backup Complete============================</div></pre></td></tr></table></figure><p>这样子，每次更新博文并deploy到服务器上之后，备份就自动启动并完成备份啦~是不是很方便呢？</p><h3 id="完成站点搜索的功能"><a href="#完成站点搜索的功能" class="headerlink" title="完成站点搜索的功能"></a>完成站点搜索的功能</h3><p>请访问链接[<a href="http://blog.csdn.net/luzheqi/article/details/52798557">http://blog.csdn.net/luzheqi/article/details/52798557</a><br>]见详细说明</p><p>在配置完之后，能够搜索，但是点击搜索结果却会出现<code>Cannot GET /undefined/</code></p><p>按照5.1.0使用algolia搜索问题这里进行的处理，在这里总结一下：</p><p>因为<code>hexo-aloglia</code>的作者没有把<code>post.path</code> 加入<code>index</code>，所以<code>data.path</code> 是<code>undefined</code>。<br>遇到这个问题，首先运行<code>npm uninstall hexo-algolia</code> 卸载之前的版本，再运行<code>npm install hexo-algolia@0.2.0 --save</code>,最后运行<code>hexo algolia</code>命令重新<code>index</code> 就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是-Hexo？&quot;&gt;&lt;a href=&quot;#什么是-Hexo？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Hexo？&quot;&gt;&lt;/a&gt;什么是 Hexo？&lt;/h2&gt;&lt;p&gt;简单的理解，它可以帮我们快速的生成博客，方便程序员做技术总结和技术分享的一个工具而已
      
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的全链路优化</title>
    <link href="http://yoursite.com/2017/09/08/Nginx/HTTP%20%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/09/08/Nginx/HTTP 的全链路优化/</id>
    <published>2017-09-08T04:27:15.000Z</published>
    <updated>2017-11-20T23:59:02.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h3><p>在日常的开发中可能按时完成工作上的业务需求，写出优雅的前端代码这大概是每一个前端工程师每天的日常工作的大部分。然而有小部分时间是属于我们的，就拿我自己来说： 10AM-18PM 的工作日常（重点是不加班），除去上下班的两小时的日常，我的空余时间是比较多的，所以这里的 <strong>小部分</strong> 相对于我自己是<strong>大部分</strong>。自我感觉就是空余拿这 <strong> 大部分</strong> 时间用来读书，技术积累. 本文就针对经常和我们打交道的 <strong>HTPP</strong> 来说事，建议首先要阅读基本 HTTP 相关的基本经典的书籍,如：</p><ul><li>《HTPP 权威指南》</li><li>《HTPP图解》</li></ul><h3 id="从浏览器输入-URL"><a href="#从浏览器输入-URL" class="headerlink" title="从浏览器输入 URL"></a>从浏览器输入 URL</h3><h3 id="浏览器代理"><a href="#浏览器代理" class="headerlink" title="浏览器代理"></a>浏览器代理</h3><h3 id="七层网络协议"><a href="#七层网络协议" class="headerlink" title="七层网络协议"></a>七层网络协议</h3><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><h3 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h3><h3 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h3><h3 id="服务程序"><a href="#服务程序" class="headerlink" title="服务程序"></a>服务程序</h3><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写作背景&quot;&gt;&lt;a href=&quot;#写作背景&quot; class=&quot;headerlink&quot; title=&quot;写作背景&quot;&gt;&lt;/a&gt;写作背景&lt;/h3&gt;&lt;p&gt;在日常的开发中可能按时完成工作上的业务需求，写出优雅的前端代码这大概是每一个前端工程师每天的日常工作的大部分。然而有小部分时
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>项目如何发布上线</title>
    <link href="http://yoursite.com/2017/09/08/Nginx/%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E4%B8%8A%E7%BA%BF/"/>
    <id>http://yoursite.com/2017/09/08/Nginx/项目如何发布上线/</id>
    <published>2017-09-08T04:27:15.000Z</published>
    <updated>2017-09-10T16:42:35.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何发布"><a href="#如何发布" class="headerlink" title="如何发布?"></a>如何发布?</h2><p>第一步, 配置nginx</p><p>先根据项目里的 <code>/src/config/nginx.conf.example</code> 文件, 修改其中的配置, 然后将文件复制到你的服务器上 nginx 所在目录的 <code>/etc/nginx/conf.d</code> 目录下, 命名为 xxx.conf 的文件. 然后重启 nginx.</p><p>第二步, 在 <code>package.json</code> 文件中添加 一条 deploy 命令放在 scripts 下.</p><p>参考: “deploy”: “react-scripts build &amp;&amp; scp -r build/ 服务器用户名@服务器域名:~/项目所在目录/“</p><p>第三步, 发布</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm run deploy</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何发布&quot;&gt;&lt;a href=&quot;#如何发布&quot; class=&quot;headerlink&quot; title=&quot;如何发布?&quot;&gt;&lt;/a&gt;如何发布?&lt;/h2&gt;&lt;p&gt;第一步, 配置nginx&lt;/p&gt;
&lt;p&gt;先根据项目里的 &lt;code&gt;/src/config/nginx.conf.exa
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 的全链路优化 - 缓存篇</title>
    <link href="http://yoursite.com/2017/09/08/HTTP/HTTP%20%E7%9A%84%E5%85%A8%E9%93%BE%E8%B7%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2017/09/08/HTTP/HTTP 的全链路优化/</id>
    <published>2017-09-08T04:27:15.000Z</published>
    <updated>2017-11-27T13:52:31.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写作背景"><a href="#写作背景" class="headerlink" title="写作背景"></a>写作背景</h3><p>在日常的开发中可能按时完成工作上的业务需求，写出优雅的前端代码这大概是每一个前端工程师每天的日常工作的大部分。但是技术积累也是一个很重要的方面，对于一个前端刚入坑的新人来说，我对 HTTP 的理解停留的层面算是比较浅层次了，因为有时候一些概会比较抽象，因此关于 HTTP 相关的文章都不敢提笔写，这次写之前也是硬着头皮看了大部分《HTPP 权威指南》,顿时间觉得自己以前错过了一个更加精彩的世界，读书解惑这句话一点也不错。但是看完之后也只能是有一个概念上的大概印象： 比如： HTTP结构， TCP/IP 协议，网关，代理，缓存等，以为看完了就可以明白 HTTP 的细枝末节的知识，看完才知道并不是这样的，还是不敢写代理，网关的内容，于是选择了比较常用的缓存，也是经常打开 network 经常能够看到的，在开始之前：<br>建议阅读 HTTP 基础相关的经典的书籍，如：</p><ul><li>《HTPP 权威指南》</li><li>《HTPP图解》</li><li>《图解TCP/IP》</li></ul><p>以上资源附百度云下载链接：<br>链接:[<a href="http://pan.baidu.com/s/1hrRygvi">http://pan.baidu.com/s/1hrRygvi</a>]  密码:xlub</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>客户端输入一个网址，中间可能会经历下面比较全的一个过程：<br>从浏览器输入URL-&gt;浏览器代理-&gt;七层网络协议-&gt;网关-&gt;反向代理服务器-&gt;应用服务器-&gt;服务程序-&gt;数据库-&gt;浏览器渲染响应, 这是我找的一张比较全面的图，看完一定印象深刻(建议：在新标签页打开图片)</p><p><img src="/img/http.png" alt=""></p><p>针对上述这张图重点介绍今天的主角： 缓存</p><blockquote><p>什么是 Web 缓存</p></blockquote><p>Web缓存是指一个Web资源（如html页面，图片，js，数据等）存在于Web服务器和客户端（浏览器）之间的副本。缓存会根据进来的请求保存输出内容的副本；当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。</p><blockquote><p>Web 缓存的作用</p></blockquote><p>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力，由于HTPP每次连接都会有时间的消耗，在加上 HTTP 的慢启动等，提供 web缓存能有效的减少网络延迟，缓存的使用能够明显加快页面打开速度，达到更好的体验。</p><blockquote><p>常见的缓存策略</p></blockquote><p>一、 浏览器缓存<br>对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的。他们分别从<strong>新鲜度</strong>和<strong>校验值</strong>两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取更新的版本。</p><p><strong>新鲜度</strong>（过期机制）：也就是缓存副本有效期。一个缓存副本必须满足以下条件，浏览器会认为它是有效的，足够新的：<br>含有完整的过期时间控制头信息（HTTP协议报头），并且仍在有效期内；<br>浏览器已经使用过这个缓存副本，并且在一个会话中已经检查过新鲜度；<br>满足以上两个情况的一种，浏览器会直接从缓存中获取副本并渲染。</p><p><strong>校验值</strong>（验证机制）：服务器返回资源的时候有时在控制头信息带上这个资源的实体标签Etag（Entity Tag），它可以用来作为浏览器再次请求过程的校验标识。如过发现校验标识不匹配，说明资源已经被修改或过期，浏览器需求重新获取资源内容。</p><ol><li>非 HTTP 协议定义的缓存</li></ol><p>浏览器缓存机制，其实主要就是基于 HTTP 协议定义的缓存机制（如： Expires； Cache-control 等）,但是也有非 HTTP 协议定义的缓存机制，如使用HTML Meta 标签，Web开发者可以在HTML页面的<head>节点中加入<meta>标签，代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Pragma"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></div></pre></td></tr></table></figure><p>上述代码的作用是告诉浏览器当前页面不被缓存，每次访问都需要去服务器拉取。使用上很简单，但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为<font color="red">代理不解析HTML内容本身</font>。</p><ol><li>基于 HTTP 协议定义的缓存</li></ol><ul><li>Expires 策略</li></ul><p>Expires Web 服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。下面是一个例子：<br><img src="/img/expires.jpeg" alt=""></p><p>Web服务器告诉浏览器在2012-11-28 03:30:01这个时间点之前，可以使用缓存文件。发送请求的时间是2012-11-28 03:25:01，即缓存5分钟。<br><strong>注意</strong>： 由于 Expires 是 HTTP 1.0  版本的东西，现在浏览器默认都是使用 HTTP 1.1 版本，所以他的作用可以忽略。</p><ul><li>Cache-control 策略</li></ul><p>Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p><p>相应头字段: Cache-Control 可选的字段有如下：<br><img src="/img/cache.png" alt=""></p><p>比如上面 expires 实现 5 分钟缓存，可以设置web服务器返回的<code>Cache-Control</code>头的值为<code>max-age=300</code>。</p><p><strong>Last-Modified/If-Modified-Since</strong></p><p>Last-Modified/If-Modified-Since要配合Cache-Control使用。</p><p>Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。<br>If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP状态码： 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的 cache。</p><p><strong>Etag/If-None-Match</strong></p><p>Etag/If-None-Match也要配合Cache-Control使用。</p><p>Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。<br>If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。</p><p><strong>Last-Modified和Etag区别？</strong></p><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间</li><li>如果某些文件会被定期生成，但有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li></ul><p>Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><p><strong>用户行为与缓存</strong><br>值得注意的是，用户行为还和缓存有关：<br><img src="/img/operate.jpeg" alt=""></p><p>总结：浏览器访问页面关于换缓存处理的大概流程</p><ul><li>浏览器第一次请求：<br><img src="/img/browser_01.png" alt=""></li><li>浏览器第二次请<br><img src="/img/browser_02.png" alt=""></li></ul><p>二、服务器端缓存</p><p><strong>代理服务器缓存</strong></p><p>代理服务器是浏览器和源服务器之间的中间服务器(充当的角色既可以是客户端也可以是服务器)，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。常见代理服务器缓存解决方案有Squid等。</p><p><strong>CDN缓存</strong></p><p>CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p><p>三、数据库数据缓存<br>Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。比如常用的缓存方案有* <a href="https://www.mysql.com/why-mysql/memcached/">memcached</a>等。</p><p>四、Web应用层缓存<br>应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。</p><h3 id="缓存运用"><a href="#缓存运用" class="headerlink" title="缓存运用"></a>缓存运用</h3><p>前面了解了Web缓存的运行机制极其重要性之后，我们可以从以下这些方面去努力改善我们的站点，保证缓存被最有效的利用，达到最佳的性能。</p><blockquote><p>同一个资源保证 URL 稳定</p></blockquote><p>URL是浏览器缓存机制的基础，所以如果一个资源需要在多个地方被引用，尽量保证URL是固定的。同时，比较推荐使用公共类库，比如Google Ajax Library等，有利于最大限度使用缓存</p><blockquote><p>给Css、js、图片等资源增加HTTP缓存头，并强制入口Html不被缓存</p></blockquote><p>对于不经常修改的静态资源，比如Css，js，图片等，可以设置一个较长的过期的时间，或者至少加上Last-Modified/Etag，而对于html页面这种入口文件，不建议设置缓存。这样既能保证在静态资源不变了情况下，可以不重发请求或直接通过304避免重复下载，又能保证在资源有更新的，只要通过给资源增加时间戳或者更换路径，就能让用户访问最新的资源</p><blockquote><p>减少对Cookie的依赖</p></blockquote><p>过多的使用Cookie会大大增加HTTP请求的负担，每次GET或POST请求，都会把Cookie都带上，增加网络传输流量，导致增长交互时间；同时Cache是很难被缓存的，应该尽量少使用，或者这在动态页面上使用。</p><blockquote><p>减少对HTTPS加密协议的使用</p></blockquote><p>通过HTTPS请求的资源，默认是不会被缓存的，必须通过特殊的配置，才能让资源得到缓存。建议只对涉及敏感信息的请求使用HTTPS传输，其他类似Css，Js，图片这些静态资源，尽量避免使用。</p><blockquote><p>多用Get方式请求动态Cgi</p></blockquote><p>虽然POST的请求方式比Get更安全，可以避免类似密码这种敏感信息在网络传输，被代理或其他人截获，但是Get请求方式更快，效率更高，而且能被缓存，建议对于那些不涉及敏感信息提交的请求尽量使用Get方式请求</p><blockquote><p>动态CGI也是可以被缓存</p></blockquote><p>如果动态脚本或CGI输入的内容在一定的时间范围内是固定的，或者根据GET参数相同，输入的内容相同，我们也认为请求是可以被缓存的，有以下几种方式，可以达到这个效果：<br>让动态脚本定期将内容改变时导出成静态文件，Web直接访问带有Last-Modified/Etag的静态文件<br>开发者可以通过代码给动态脚本的响应头中添加Cache-Control: max-age，告诉浏览器在过期前可以直接使用副本<br>通过代码给动态脚本的响应头添加Last-Modified/Etag信息，浏览器再次请求的时候，可以通过解析If-Modified-Since/If-None-Match得知浏览器是否存在缓存，由代码逻辑控制是否返回304</p><h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><blockquote><p>HTML5 离线应用</p></blockquote><p>即使对站点的资源都实施了比较好的缓存策略，但是在断网的情况下，是无法访问的。因为入口的HTML页面出于运维的考虑，不会对其进行缓存。 HTML5的 Cache Manifest 离线应该特性就能够帮我们构建离线也能使用的站点，所有的资源都是使用浏览器本地缓存，当然前提是要求在连接网络的前提下，使用过一次网络。</p><p><strong>实现离线访问特性步骤</strong></p><ol><li>在服务器上添加 MIME TYPE ,让服务器能够识别manifest后缀的文件</li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AddType <span class="built_in">text</span>/cache-manifest manifest</div></pre></td></tr></table></figure><ol><li>创建一个后缀名为 .manifest 的文件，把需要的文件按照格式写在里面，并用注释标注版本</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CACHE</span> MANIFEST</div><div class="line"># 直接缓存的文件</div><div class="line"><span class="keyword">CACHE</span>:</div><div class="line"><span class="keyword">Path</span>/<span class="keyword">to</span>/cache.js</div><div class="line"># <span class="keyword">version</span>：<span class="number">2012</span><span class="number">-03</span><span class="number">-20</span></div></pre></td></tr></table></figure><ol><li>给 <html> 标签加  manifest 属性， 并引用 manifest 文件</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"path/to/name-of.manifest"</span>&gt;</span></div></pre></td></tr></table></figure><p><strong>离线应用访问及更新流程</strong></p><ol><li><p>第一次访问离线应用的入口页HTML（引用了manifest文件），正常发送请求，获取manifest文件并在本地缓存，陆续拉取manifest中的需要缓存的文件</p></li><li><p>再次访问时，无论在线离线与否，都会直接从缓存中获取入口页HTML和其他缓存的文件进行展示。如果此时在线，浏览器会发送请求到服务器请求manifest文件，并与第一次访问的副本进行比对，如果发现版本不一致，会陆续发送请求重新拉取入口文件HTML和需要缓存的文件并更新本地缓存副本。如果处于离线，则会从缓存文件中读取，但是不能保证当前展示缓存的页面是最新的</p></li><li><p>之后的访问重复第2步的行为</p></li></ol><p><strong>离线机制的缓存用途</strong></p><p>从Manifest的机制来看，即使我们不是为了创建离线应用，也同样可以使用这种机制用于缓存文件，可以说是给Web缓存提供多一种可以选择的途径。</p><p><strong>存在的问题：缓存文件更新控制不灵活</strong></p><p>就目前HTML5提供的manifest机制来讲，一个页面只能引用一个manifest页面，而且一旦发现这个manifest改变了，就会把里面所有定义的缓存文件全部重新拉取一遍，不管实际上有没有更新，控制比较不灵活。针对这个问题，也有的同学提出了一些建议，比如把需要缓存的文件分模块切分到不同 manifest中，并分开用HTML引用，再使用强大的iframe嵌入到入口页面，这样就当某一个模式需要有更新，不会导致其他模块的文件也重新拉取一遍。</p><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>然而在离线的情况下，基本也是只有页面框架，大量的页面空白和 ajax 请求超时，基本也相当于不可用。那么，花了这么大力气定制的本地化机制就仅仅保证打开的时候可看不可用吗？有什么办法可以改善吗？</p><p>答案是有的，这时 Web Storage 和 Web Database 就可以派上用场了<br>一些典型的离线场景及处理方案：<br>离线写操作：将 Ajax 请求以及相关参数保存到 localStorage 队列中，网络上线后，触发执行队列中的操作<br>离线读操作：页面上有需要通过 Ajax 获取动态的数据或远程图片进行渲染的块，可以通过前端 hardcode 一些默认数据，并且将最近一次 ajax 结果存储到 localStorage 中，图片可以转为 base64 字符串才用同样的方式处理</p><p>HTML5给我们提供本地存储localstorage特性，严格来讲，其实已经不算传统Web缓存的范畴。因为它存储的地方是跟Web缓存分开的，是浏览器重新开辟的一个地方。</p><p><strong>Localstorage的缓存用途</strong></p><p>Localstorage设计的本意可能是用来存储一些用户操作的个性化设置的文本类型的信息和数据，当我们其实也可能拿来当Web缓存区使用，比如我们可以将Base64格式编码的图片信息，存在localstorage中，再次访问时，直接本地获取后，使用Css3的Data:image的方式直接展现出来。</p><p><strong>存在的问题：大小限制</strong><br>按照目前标准，目前浏览器只给每个独立的域名提供5M的存储空间，当存储超过5M，浏览器就会弹出警告框。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写作背景&quot;&gt;&lt;a href=&quot;#写作背景&quot; class=&quot;headerlink&quot; title=&quot;写作背景&quot;&gt;&lt;/a&gt;写作背景&lt;/h3&gt;&lt;p&gt;在日常的开发中可能按时完成工作上的业务需求，写出优雅的前端代码这大概是每一个前端工程师每天的日常工作的大部分。但是技术积累也
      
    
    </summary>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>简单实用的css代码片段</title>
    <link href="http://yoursite.com/2017/08/15/CSS/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%94%A8%E7%9A%84css%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"/>
    <id>http://yoursite.com/2017/08/15/CSS/简单实用的css代码片段/</id>
    <published>2017-08-15T10:08:31.000Z</published>
    <updated>2018-01-09T14:11:19.118Z</updated>
    
    <content type="html"><![CDATA[<p>(<a href="https://github.com/qianlongo/cssSkills">https://github.com/qianlongo/cssSkills</a>)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(&lt;a href=&quot;https://github.com/qianlongo/cssSkills&quot;&gt;https://github.com/qianlongo/cssSkills&lt;/a&gt;)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>axios的配置配置问题</title>
    <link href="http://yoursite.com/2017/08/15/Vue/axios%E7%9A%84%E9%85%8D%E7%BD%AE%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/08/15/Vue/axios的配置配置问题/</id>
    <published>2017-08-15T07:22:59.000Z</published>
    <updated>2017-09-10T16:42:35.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前写Vue项目的时候都是使用vue-resource做为项目ajax库，在11月份的某一天尤大微博的更新表示ajax的库应该是通用的，放弃了对vue-resource的技术支持，推荐使用axios。</p></blockquote><p>看下官方的版本， <code>vue resource</code>官方已经停止了对它的更新</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> axios</div></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">axios.get(<span class="string">'/user?ID=12345'</span>)</div><div class="line">.then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(response);</div><div class="line">&#125;)</div><div class="line">.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="参数的配置"><a href="#参数的配置" class="headerlink" title="参数的配置"></a>参数的配置</h2><ul><li>Axios的参数配置有很多，下面详细列举了一下：</li><li>url —— 用来向服务器发送请求的url</li><li>method —- — 请求方法，默认是GET方法</li><li>baseURL —— 基础URL路径，假如url不是绝对路径，如<a href="https://some-domain.com/api/v1/login?name=jack,那么向服务器发送请求的URL将会是baseURL">https://some-domain.com/api/v1/login?name=jack,那么向服务器发送请求的URL将会是baseURL</a> + url。</li><li>transformRequest —— transformRequest方法允许在请求发送到服务器之前修改该请求，此方法只适用于PUT、POST和PATCH方法中。而且，此方法最后必须返回一个string、ArrayBuffer或者Stream。</li><li>transformResponse —— transformResponse方法允许在数据传递到then/catch之前修改response数据。此方法最后也要返回数据。</li><li>headers —— 发送自定义Headers头文件，头文件中包含了http请求的各种信息。</li><li>params —— params是发送请求的查询参数对象，对象中的数据会被拼接成url?param1=value1&amp;param2=value2。</li><li>paramsSerializer —— params参数序列化器。</li><li>data —— data是在发送POST、PUT或者PATCH请求的数据对象。</li><li>timeout —— 请求超时设置，单位为毫秒</li><li>withCredentials —— 表明是否有跨域请求需要用到证书</li><li>adapter —— adapter允许用户处理更易于测试的请求。返回一个Promise和一个有效的response</li><li>auth —— auth表明提供凭证用于完成http的身份验证。这将会在headers中设置一个Authorization授权信息。自定义Authorization授权要设置在headers中。</li><li>responseType —— 表示服务器将返回响应的数据类型，有arraybuffer、blob、document、json、text、stream这6个类型，默认是json类似数据。</li><li>xsrfCookieName —— 用作 xsrf token 值的 cookie 名称</li><li>xsrfHeaderName —— 带有 xsrf token 值 http head 名称</li><li>onUploadProgress —— 允许在上传过程中的做一些操作</li><li>onDownloadProgress —— 允许在下载过程中的做一些操作</li><li>maxContentLength —— 定义了接收到的response响应数据的最大长度。</li><li>validateStatus —— validateStatus定义了根据HTTP响应状态码决定是否接收或拒绝获取到的promise。如果 validateStatus 返回 true (或设置为 null 或 undefined ),promise将被接收;否则,promise将被拒绝。</li><li>maxRedirects —— maxRedirects定义了在node.js中redirect的最大值，如果设置为0，则没有redirect。</li><li>httpAgent —— 定义在使用http请求时的代理</li><li>httpsAgent —— 定义在使用https请求时的代理</li><li>proxy —— proxy定义代理服务器的主机名和端口，auth</li><li>cancelToken —— cancelToken定义一个 cancel token 用于取消请求</li></ul><p>详细的配置文件如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  /* `url`是将用于请求的服务器URL*/</div><div class="line">  url: &apos;/user&apos;,</div><div class="line">  /* `method`是发出请求时使用的请求方法 */</div><div class="line">  method: &apos;get&apos;, /* 默认*/</div><div class="line">  /* `baseURL`将被添加到`url`前面，除非`url`是绝对的。*/</div><div class="line">  /* 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。*/</div><div class="line">  baseURL: &apos;https:/*some-domain.com/api/&apos;,</div><div class="line">  /* `transformRequest`允许在请求数据发送到服务器之前对其进行更改*/</div><div class="line">  /* 这只适用于请求方法&apos;PUT&apos;，&apos;POST&apos;和&apos;PATCH&apos;*/</div><div class="line">  /* 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream*/</div><div class="line">  transformRequest: [function (data) &#123;</div><div class="line">    /* 做任何你想要的数据转换*/</div><div class="line">    return data;</div><div class="line">  &#125;],</div><div class="line">  /* `transformResponse`允许在 then / catch之前对响应数据进行更改*/</div><div class="line">  transformResponse: [function (data) &#123;</div><div class="line">    /* Do whatever you want to transform the data*/</div><div class="line">    return data;</div><div class="line">  &#125;],</div><div class="line">  /* `headers`是要发送的自定义 headers*/</div><div class="line">  headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;,</div><div class="line">  /* `params`是要与请求一起发送的URL参数*/</div><div class="line">  /* 必须是纯对象或URLSearchParams对象*/</div><div class="line">  params: &#123;</div><div class="line">    ID: 12345</div><div class="line">  &#125;,</div><div class="line">  /* `paramsSerializer`是一个可选的函数，负责序列化`params`*/</div><div class="line">  /* (e.g. https:/*www.npmjs.com/package/qs, http:/*api.jquery.com/jquery.param/)*/</div><div class="line">  paramsSerializer: function(params) &#123;</div><div class="line">    return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;)</div><div class="line">  &#125;,</div><div class="line">  /* `data`是要作为请求主体发送的数据*/</div><div class="line">  /* 仅适用于请求方法“PUT”，“POST”和“PATCH”*/</div><div class="line">  /* 当没有设置`transformRequest`时，必须是以下类型之一：*/</div><div class="line">  /* - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams*/</div><div class="line">  /* - Browser only: FormData, File, Blob*/</div><div class="line">  /* - Node only: Stream*/</div><div class="line">  data: &#123;</div><div class="line">    firstName: &apos;Fred&apos;</div><div class="line">  &#125;,</div><div class="line">  /* `timeout`指定请求超时之前的毫秒数。*/</div><div class="line">  /* 如果请求的时间超过&apos;timeout&apos;，请求将被中止。*/</div><div class="line">  timeout: 1000,</div><div class="line">  /* `withCredentials`指示是否跨站点访问控制请求*/</div><div class="line">  /* should be made using credentials*/</div><div class="line">  withCredentials: false, /* default*/</div><div class="line">  /* `adapter&apos;允许自定义处理请求，这使得测试更容易。*/</div><div class="line">  /* 返回一个promise并提供一个有效的响应(参见[response docs](＃response-api))*/</div><div class="line">  adapter: function (config) &#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;,</div><div class="line">  /* `auth&apos;表示应该使用 HTTP 基本认证，并提供凭据。*/</div><div class="line">  /* 这将设置一个`Authorization&apos;头，覆盖任何现有的`Authorization&apos;自定义头，使用`headers`设置。*/</div><div class="line">  auth: &#123;</div><div class="line">    username: &apos;janedoe&apos;,</div><div class="line">    password: &apos;s00pers3cret&apos;</div><div class="line">  &#125;,</div><div class="line">  /* “responseType”表示服务器将响应的数据类型*/</div><div class="line">  /* 包括 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos;</div><div class="line">  responseType: &apos;json&apos;, /* default*/</div><div class="line">  /*`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称*/</div><div class="line">  xsrfCookieName: &apos;XSRF-TOKEN&apos;, /* default*/</div><div class="line">  /* `xsrfHeaderName`是携带xsrf令牌值的http头的名称*/</div><div class="line">  xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, /* default*/</div><div class="line">  /* `onUploadProgress`允许处理上传的进度事件*/</div><div class="line">  onUploadProgress: function (progressEvent) &#123;</div><div class="line">    /* 使用本地 progress 事件做任何你想要做的*/</div><div class="line">  &#125;,</div><div class="line">  /* `onDownloadProgress`允许处理下载的进度事件*/</div><div class="line">  onDownloadProgress: function (progressEvent) &#123;</div><div class="line">    /* Do whatever you want with the native progress event*/</div><div class="line">  &#125;,</div><div class="line">  /* `maxContentLength`定义允许的http响应内容的最大大小*/</div><div class="line">  maxContentLength: 2000,</div><div class="line">  /* `validateStatus`定义是否解析或拒绝给定的promise*/</div><div class="line">  /* HTTP响应状态码。如果`validateStatus`返回`true`(或被设置为`null` promise将被解析;否则，promise将被*/</div><div class="line">  /* 拒绝。*/</div><div class="line">  validateStatus: function (status) &#123;</div><div class="line">    return status &gt;= 200 &amp;&amp; status &lt; 300; /* default</div><div class="line">  &#125;,</div><div class="line">  /* `maxRedirects`定义在node.js中要遵循的重定向的最大数量。*/</div><div class="line">  /* 如果设置为0，则不会遵循重定向。*/</div><div class="line">  maxRedirects: 5, /* 默认*/</div><div class="line">  /* `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。*/</div><div class="line">  /* 允许配置类似`keepAlive`的选项，*/</div><div class="line">  /* 默认情况下不启用。*/</div><div class="line">  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),</div><div class="line">  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),</div><div class="line">  /* &apos;proxy&apos;定义代理服务器的主机名和端口*/</div><div class="line">  /* `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。*/</div><div class="line">  /* 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。*/</div><div class="line">  proxy: &#123;</div><div class="line">    host: &apos;127.0.0.1&apos;,</div><div class="line">    port: 9000,</div><div class="line">    auth: : &#123;</div><div class="line">      username: &apos;mikeymike&apos;,</div><div class="line">      password: &apos;rapunz3l&apos;</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  /* “cancelToken”指定可用于取消请求的取消令牌*/</div><div class="line">  /* (see Cancellation section below for details)*/</div><div class="line">  cancelToken: new CancelToken(function (cancel) &#123;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="Response返回"><a href="#Response返回" class="headerlink" title="Response返回"></a>Response返回</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  // 服务器返回的数据</div><div class="line">  data: &#123;&#125;,</div><div class="line">  // HTTP状态吗</div><div class="line">  status: 200,</div><div class="line">  // 服务器返回的消息</div><div class="line">  statusText: &apos;OK&apos;,</div><div class="line">  // 返回头</div><div class="line">  headers: &#123;&#125;,</div><div class="line">  // 再次返回我们的配置</div><div class="line">  config: &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="统一Config的配置"><a href="#统一Config的配置" class="headerlink" title="统一Config的配置"></a>统一Config的配置</h2><p>在接口测试中，我们经常需要切换线上环境和测试环境，这里我们都可以通过Config来配置，这样我们所有的发起的请求都是通过这个基本的URL走了。</p><h2 id="Interceptors拦截器"><a href="#Interceptors拦截器" class="headerlink" title="Interceptors拦截器"></a>Interceptors拦截器</h2><p>这里我必须重点介绍，在我们发起大量的请求时候，需要对请求做统一的处理那就用到它了。笔者在使用了vue-resource和axios之后亲身比较，axios的配置更加人性化。<br>官方的API上这样介绍</p><h3 id="request统一操作"><a href="#request统一操作" class="headerlink" title="request统一操作"></a>request统一操作</h3><p>如果是<code>POST</code>的请求，配置中可不能用params字段了，需要使用data字段。<br>这里有个小地方需要注意，<code>POST</code>的传参需要序列化，不然服务端不会正确的接收哦，会报错。所以这里我们要对request的数据进行一次序列化。这里我用了<code>qs</code>,大家需要<code>install</code>一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></div><div class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'qs'</span></div><div class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span>;</div><div class="line"><span class="comment">//POST传参序列化</span></div><div class="line">axios.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span>(config.method  === <span class="string">'post'</span>)&#123;</div><div class="line">    config.data = qs.stringify(config.data);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> config;</div><div class="line">&#125;,(error) =&gt;&#123;</div><div class="line">   alert(<span class="string">"错误的传参"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="response统一操作"><a href="#response统一操作" class="headerlink" title="response统一操作"></a>response统一操作</h3><p>也就是说我们可以统一的在发起请求前，或者获得数据，对其进行统一的操作。这点非常的高效，在笔者的项目中，接口会返回一个code,就和微信API一样，code为200代表返回请求数据正确为其它时就自动跳出弹窗打印消息即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//code状态码200判断</span></div><div class="line">axios.interceptors.response.use(<span class="function">(<span class="params">res</span>) =&gt;</span>&#123;</div><div class="line">  <span class="keyword">if</span>(res.data.code != <span class="string">'200'</span>)&#123;</div><div class="line">    alert(res.data.msg);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> res;</div><div class="line">&#125;, (error) =&gt; &#123;</div><div class="line">  alert(<span class="string">"网络异常"</span>);</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</div></pre></td></tr></table></figure><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>Promise在安卓4.4。3以下的手机还是不支持Promise的，所以会报错。需要引入 <code>npm install babel-polyfill</code><br>和 <code>npm install babel-runtime</code>, 在入口文件上加上即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span></div></pre></td></tr></table></figure><h2 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h2><h3 id="你可以通过一个cancel-token来取消一个请求"><a href="#你可以通过一个cancel-token来取消一个请求" class="headerlink" title="你可以通过一个cancel token来取消一个请求"></a>你可以通过一个cancel token来取消一个请求</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CancelToken = axios.CancelToken;</div><div class="line"><span class="keyword">var</span> source = CancelToken.source();</div><div class="line"></div><div class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</div><div class="line">  <span class="attr">cancelToken</span>: source.token</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">thrown</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(axios.isCancel(thrown))&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Request canceled'</span>,thrown.message);</div><div class="line">  &#125;<span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//handle error</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h3 id="你也可以给cancelToken构造函数传递一个executor-function来创建一个cancel-token"><a href="#你也可以给cancelToken构造函数传递一个executor-function来创建一个cancel-token" class="headerlink" title="你也可以给cancelToken构造函数传递一个executor function来创建一个cancel token:"></a>你也可以给cancelToken构造函数传递一个executor function来创建一个cancel token:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> cancelToken = axios.CancelToken;</div><div class="line"><span class="keyword">var</span> cancel;</div><div class="line">axios.get(<span class="string">'/user/12345'</span>,&#123;</div><div class="line">  <span class="attr">cancelToken</span>: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;</div><div class="line">    <span class="comment">//这个executor函数接受一个cancel function作为参数</span></div><div class="line">    cancel = c;</div><div class="line">  &#125;)</div><div class="line">&#125;)</div><div class="line"><span class="comment">//取消请求</span></div><div class="line">cancel();</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;以前写Vue项目的时候都是使用vue-resource做为项目ajax库，在11月份的某一天尤大微博的更新表示ajax的库应该是通用的，放弃了对vue-resource的技术支持，推荐使用axios。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看下
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>什么是commonjs</title>
    <link href="http://yoursite.com/2017/08/04/Node/%E4%BB%80%E4%B9%88%E6%98%AFcommonjs/"/>
    <id>http://yoursite.com/2017/08/04/Node/什么是commonjs/</id>
    <published>2017-08-04T06:36:17.000Z</published>
    <updated>2017-09-10T16:42:35.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>在node中是遵循CommonJS 的规范的， 一个文件就是一个模块，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;模块化&quot;&gt;&lt;a href=&quot;#模块化&quot; class=&quot;headerlink&quot; title=&quot;模块化&quot;&gt;&lt;/a&gt;模块化&lt;/h1&gt;&lt;p&gt;在node中是遵循CommonJS 的规范的， 一个文件就是一个模块，在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可
      
    
    </summary>
    
    
      <category term="CommonJS" scheme="http://yoursite.com/tags/CommonJS/"/>
    
  </entry>
  
  <entry>
    <title>比npm更加强大的yarn</title>
    <link href="http://yoursite.com/2017/07/31/Npm/%E6%AF%94npm%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%E7%9A%84yarn/"/>
    <id>http://yoursite.com/2017/07/31/Npm/比npm更加强大的yarn/</id>
    <published>2017-07-31T02:14:59.000Z</published>
    <updated>2017-09-10T16:42:35.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yarn的简单的介绍"><a href="#yarn的简单的介绍" class="headerlink" title="yarn的简单的介绍"></a>yarn的简单的介绍</h1><p>Yarn是facebook发布的一款取代npm的包管理工具。Yarn的官网是：(Yarn)[<a href="https://yarnpkg.com/zh-Hans/">https://yarnpkg.com/zh-Hans/</a>]<br>相比于npm有快速、安全、可靠的优势</p><h1 id="Yarn的优势"><a href="#Yarn的优势" class="headerlink" title="Yarn的优势"></a>Yarn的优势</h1><h2 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h2><p>先说速度快。网络性能优异：将请求高效队列化，依赖包只要被装过一次，就会被缓存到本机，再次安装时直接从缓存中读取。npm会等一个包完全安装完才跳到下一个包，但yarn会并行执行包，因此速度会快很多。网上有不少比较npm和yarn安装同样多依赖的执行速度，yarn在速度方面优势明显。实际项目中体验一下真是飞一样的速度，谁有试过谁知道~</p><h2 id="离线模式"><a href="#离线模式" class="headerlink" title="离线模式"></a>离线模式</h2><p>关于离线模式，本人能力有限，对CI系统的了解比较浅薄，因此对facebook介绍的无法离线使用npm的痛点感受不深。离线的原理比较简单，安装过的包会被保存进缓存目录，以后安装就直接从缓存中复制过来。</p><h2 id="高确定性"><a href="#高确定性" class="headerlink" title="高确定性"></a>高确定性</h2><p>无论安装顺序如何，同样的依赖包都将会以完全一样的方式安装。</p><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>npm用下来比较强的一个痛点就是：当包 的依赖层次比较深时，版本控制不够精确。会出现相同<code>package.json</code>，但不同人的电脑上安装出不同版本的依赖包，出现类似 “我电脑上是好的，没问题呀”的bug很难查找。你可以使用<code>npm-shrinkwrap</code>来实现版本固化，版本信息会写入<code>npm-shrinkwrap.json</code>文件中，但它毕竟不是npm的标准配置。</p><p>而yarn天生就能实现版本固化。会生成一个类似<code>npm-shrinkwrap.json</code>的<code>yarn.lock</code>文件，文件内会描述包自身的版本号，还会锁定所有它依赖的包的版本号.</p><p><code>yarn.lock</code>存储这你的每个包的确切依赖版本，能确保从本地开发到生产环境，所有机器上都有精确相同的依赖版本。</p><h1 id="Yarn-常用的命令"><a href="#Yarn-常用的命令" class="headerlink" title="Yarn 常用的命令"></a>Yarn 常用的命令</h1><h2 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm <span class="keyword">install</span> yarn -g</div></pre></td></tr></table></figure><h2 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yarn <span class="comment">--version</span></div></pre></td></tr></table></figure><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">yarn init</span></div></pre></td></tr></table></figure><p>同<code>npm init</code>，执行输入信息后，会生成<code>package.json</code>文件</p><h2 id="Yarn-的配置项"><a href="#Yarn-的配置项" class="headerlink" title="Yarn 的配置项"></a>Yarn 的配置项</h2><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yarn config list                                <span class="comment">//显示所有配置项</span></div><div class="line">yarn config <span class="built_in">get</span> &lt;<span class="built_in">key</span>&gt;                           <span class="comment">//显示某配置项</span></div><div class="line">yarn config <span class="keyword">delete</span> &lt;<span class="built_in">key</span>&gt;                        <span class="comment">//删除某配置项</span></div><div class="line">yarn config <span class="built_in">set</span> &lt;<span class="built_in">key</span>&gt; &lt;<span class="built_in">value</span>&gt; [-g|--global]     <span class="comment">//设置配置项</span></div></pre></td></tr></table></figure><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yarn <span class="keyword">install</span>                     //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock</div><div class="line">yarn <span class="keyword">install</span> <span class="comment">--flat              //安装一个包的单一版本</span></div><div class="line">yarn <span class="keyword">install</span> <span class="comment">--force             //强制重新下载所有包</span></div><div class="line">yarn <span class="keyword">install</span> <span class="comment">--production        //只安装dependencies里的包</span></div><div class="line">yarn <span class="keyword">install</span> <span class="comment">--no-lockfile       //不读取或生成yarn.lock</span></div><div class="line">yarn <span class="keyword">install</span> <span class="comment">--pure-lockfile     //不生成yarn.lock</span></div></pre></td></tr></table></figure><h2 id="添加包"><a href="#添加包" class="headerlink" title="添加包"></a>添加包</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">yarn <span class="keyword">add</span><span class="bash"> [package]</div><div class="line"></span>yarn <span class="keyword">add</span><span class="bash"> [package]@[version]</div><div class="line"></span>yarn <span class="keyword">add</span><span class="bash"> [package]@[tag]</div><div class="line"></span></div><div class="line">//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：</div><div class="line">yarn <span class="keyword">add</span><span class="bash"> --dev/-D        //加到 devDependencies</div><div class="line"></span>yarn <span class="keyword">add</span><span class="bash"> --peer/-P       //加到 peerDependencies</div><div class="line"></span>yarn <span class="keyword">add</span><span class="bash"> --optional/-O   //加到 optionalDependencies</div><div class="line"></span></div><div class="line">//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：</div><div class="line">yarn <span class="keyword">add</span><span class="bash"> --exact/-E    //安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版</div><div class="line"></span>yarn <span class="keyword">add</span><span class="bash"> --tilde/-T      //安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0</span></div></pre></td></tr></table></figure><h2 id="global参数的安装"><a href="#global参数的安装" class="headerlink" title="global参数的安装"></a>global参数的安装</h2><p>yarn推荐你将包安装在项目中，但同<code>npm</code>一样，你也可以全局安装包，用<code>yarn global add</code>就行了。<code>yarn global</code>可用在<code>add</code>，<code>upgrade</code>，<code>remove</code>命令前。但注意<code>global</code>必须紧接在<code>yarn</code>后面，例如<code>yarn add global</code>是非法的，<code>yarn</code>会尝试去安装一个名为“global”的包</p><h2 id="升级-移除单个包"><a href="#升级-移除单个包" class="headerlink" title="升级 / 移除单个包"></a>升级 / 移除单个包</h2><p>值得注意的是升级 / 移除单个包（均会更新package.json和yarn.lock）：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">yarn upgrade <span class="string">[package]</span></div><div class="line">yarn upgrade <span class="string">[package]</span>@<span class="string">[version]</span></div><div class="line">yarn upgrade <span class="string">[package]</span>@<span class="string">[tag]</span></div><div class="line">yarn remove <span class="string">[package]</span></div></pre></td></tr></table></figure><h2 id="安装包的缓存"><a href="#安装包的缓存" class="headerlink" title="安装包的缓存"></a>安装包的缓存</h2><p>Yarn会将安装的包缓存起来</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yarn <span class="keyword">cache</span> ls          <span class="comment">//列出所有本地缓存了的包</span></div><div class="line">yarn <span class="keyword">cache</span> dir         <span class="comment">//列出本地缓存的位置</span></div><div class="line">yarn <span class="keyword">cache</span> clean       <span class="comment">//清除本地缓存</span></div></pre></td></tr></table></figure><h2 id="检查包"><a href="#检查包" class="headerlink" title="检查包"></a>检查包</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yarn<span class="built_in"> check </span>              // 验证当前项目 package.json 里的依赖版本和 yarn 的 lock 文件是否匹配。</div><div class="line">yarn<span class="built_in"> check </span>--integrity  //检查package.json里的依赖版本的hash值和yarn.lock里是否一致，有助于验证包依赖没有更改</div></pre></td></tr></table></figure><h2 id="其他的一些命令"><a href="#其他的一些命令" class="headerlink" title="其他的一些命令"></a>其他的一些命令</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">yarn   运行package.json中预定义的脚本</div><div class="line">yarn login/logout  保存你的用户名、邮箱 / 删除你的用户名、邮箱</div><div class="line">yarn owner <span class="keyword">add</span><span class="bash"></div><div class="line">yarn owner rm</div><div class="line"></span>yarn publish  将包发布到npm  参数有： –tag：版本标签；–access：公开（public）还是限制的（restricted）</div><div class="line">yarn version package-name 卸载包，更新package.json和yarn.lock</div><div class="line">yarn tag 显示包的标签  参数：  <span class="keyword">add</span><span class="bash">/rm/ls</div><div class="line"></span>yarn <span class="keyword">run</span><span class="bash"> <span class="built_in">test</span> 测试</div><div class="line"></span>yarn link package-name 开发时链接依赖包，以便在其他项目中使用</div><div class="line">yarn unlink package-name 取消链接的依赖包</div><div class="line">yarn team 管理团队  参数： create/destroy/<span class="keyword">add</span><span class="bash">/rm/ls</div><div class="line"></span></div><div class="line">yarn global 全局安装依赖包 yarn global &lt;<span class="keyword">add</span><span class="bash">/bin/ls/remove/upgrade&gt; [–prefix] –prefix 包路径前缀</span></div></pre></td></tr></table></figure><h2 id="npm和yarn的无缝迁移"><a href="#npm和yarn的无缝迁移" class="headerlink" title="npm和yarn的无缝迁移"></a>npm和yarn的无缝迁移</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">因为yarn和<span class="built_in">npm</span>一样使用package.json，因此如果你的项目中正在使用<span class="built_in">npm</span>可以无缝对接yarn。如果用下来实在不喜欢yarn，只要删除项目中的yarn.lock文件，继续使用<span class="built_in">npm</span>命令就行了。但我相信你用过yarn，就再也回不去了~</div></pre></td></tr></table></figure><p>具体的使用方式:<br>大多情况，从npm客户端迁移至Yarn客户端都是很方便的。<br>package.json文件依然可用，你只要在已有目录执行以下命令即可：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$ </span>yarn</div></pre></td></tr></table></figure><p>要添加依赖，你可以使用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yarn <span class="keyword">add</span><span class="bash"> &lt;package&gt;</span></div></pre></td></tr></table></figure><p>执行以上两个命令后，yarn都会在项目根目录创建或更新yarn.lock文件。如果你要将项目发布或者共享给同事，请确保包含yarn.lock文件。</p><p>执行以上两个命令中的任一个，项目都会转换成yarn客户端。So easy，对吧？！</p><h2 id="Yarn-和-npm-中命令的对比"><a href="#Yarn-和-npm-中命令的对比" class="headerlink" title="Yarn 和 npm 中命令的对比"></a>Yarn 和 npm 中命令的对比</h2><table><thead><tr><th>npm 命令</th><th>Yarn 命令</th><th>备注</th></tr></thead><tbody><tr><td>npm install</td><td>yarn install</td><td>安装所有依赖包（依据package.json中的依赖配置参数）</td></tr><tr><td>(N/A)</td><td>yarn install –flat</td><td>单版本模式</td></tr><tr><td>(N/A)</td><td>yarn install –har</td><td>生成har文件，记录安装时网络请求性能</td></tr><tr><td>(N/A)</td><td>yarn install –no-lockfile</td><td>不读写lockfile方式</td></tr><tr><td>(N/A)</td><td>yarn install –pure-lockfile</td><td>不生成yarn.lock文件</td></tr><tr><td>npm install [package]</td><td>(N/A)</td><td>安装依赖</td></tr><tr><td>npm install –save [package]</td><td>yarn add [package]</td><td>添加生产模式依赖到项目</td></tr><tr><td>npm install –save-dev [package]</td><td>yarn add [package] [–dev/-D]</td><td>添加开发模式的依赖</td></tr><tr><td>(N/A)</td><td>yarn add [package] [–peer/-P]</td><td>对等模式添加依赖，发布/分享项目时的依赖</td></tr><tr><td>npm install –save-optional [package]</td><td>yarn add [package] [–optional/-O]</td><td>添加可选依赖包</td></tr><tr><td>npm install –save-exact [package]</td><td>yarn add [package] [–exact/-E]</td><td>精准添加某版本的包</td></tr><tr><td>(N/A)</td><td>yarn add [package] [–tilde/-T]</td><td>添加同一次版本的包，如指定版本为1.2.3，可接受1.2.x的其他版本，但不接受1.3.x的版本</td></tr><tr><td>npm install –global [package]</td><td>yarn global add [package]</td><td>添加全局包</td></tr><tr><td>npm rebuild</td><td>yarn install –force</td><td>重建</td></tr><tr><td>npm uninstall [package]</td><td>(N/A)</td><td>删除本地依赖包</td></tr><tr><td>npm uninstall –save [package]</td><td>yarn remove [package]</td><td>删除正式依赖包</td></tr><tr><td>npm uninstall –save-dev [package]</td><td>yarn remove [package]</td><td>删除开发依赖包</td></tr><tr><td>npm uninstall –save-optional [package]</td><td>yarn remove [package]</td><td>删除可选依赖包</td></tr><tr><td>npm cache clean</td><td>yarn cache clean</td><td>清除缓存</td></tr><tr><td>rm -rf node_modules &amp;&amp; npm install</td><td>yarn upgrade</td><td>更新包管理器自身</td></tr></tbody></table><p>转载请注明出处！ 来源: (<a href="http://docs.shellway.cn/learning-yarn/">http://docs.shellway.cn/learning-yarn/</a>)</p><h2 id="更重依赖的类型"><a href="#更重依赖的类型" class="headerlink" title="更重依赖的类型"></a>更重依赖的类型</h2><p>项目中的package.json 文件通常会包含多种依赖， 如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"name"</span>: <span class="string">"my-project"</span>,</div><div class="line">  <span class="attr">"dependencies"</span>: &#123;</div><div class="line">    <span class="attr">"package-a"</span>: <span class="string">"^1.0.0"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"devDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"package-b"</span>: <span class="string">"^1.2.1"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"peerDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"package-c"</span>: <span class="string">"^2.5.4"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">"optionalDependencies"</span>: &#123;</div><div class="line">    <span class="attr">"package-d"</span>: <span class="string">"^3.1.0"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>一、dependencies —— 普通依赖<br>运行项目时需要用到的依赖。如React、ImmutableJS。</p><p>二、devDependencies —— 开发依赖<br>开发时使用到的依赖。如Babel（ES6转ES5）、Flow（JS静态类型检查）</p><p>三、peerDependencies —— 对等依赖，发布依赖包时用<br>对等依赖——依赖的特殊类型，你在发布依赖包时使用。</p><p>使用对等依赖意味着，别人使用你的程序时，安装的依赖需要跟你安装的一毛一样。这对像React这样的包特别有用，它经常需要复制一份react-dom供安装者使用。</p><p>四、optionalDependencies —— 可选依赖<br>可选的依赖包，如果此包安装失败，Yarn依然会提示安装进程成功。<br>对非必须的依赖包很实用，如果安装失败，你可以选择其他的包替代。如Watchman。</p><p>五、bundledDependencies —— 要打包的依赖/捆绑依赖<br>在发布包时，会一起打包的依赖包。它是由包名组成的数组。<br>捆绑依赖包应该下载到项目本地。功能跟普通依赖是一样的。运行 $ yarn pack 时，它们也会被打包。<br>捆绑依赖是为了解决有些包可能在npm找不到，或者在你需要把你自己的项目作为模块使用时。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yarn的简单的介绍&quot;&gt;&lt;a href=&quot;#yarn的简单的介绍&quot; class=&quot;headerlink&quot; title=&quot;yarn的简单的介绍&quot;&gt;&lt;/a&gt;yarn的简单的介绍&lt;/h1&gt;&lt;p&gt;Yarn是facebook发布的一款取代npm的包管理工具。Yarn的官网是
      
    
    </summary>
    
    
      <category term="yarn" scheme="http://yoursite.com/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>如何升级自己的项目相关包的依赖</title>
    <link href="http://yoursite.com/2017/07/27/Work/%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2017/07/27/Work/如何升级自己的项目/</id>
    <published>2017-07-27T06:40:25.000Z</published>
    <updated>2017-09-10T16:42:35.717Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何查看项目中安装包的版本"><a href="#如何查看项目中安装包的版本" class="headerlink" title="如何查看项目中安装包的版本"></a>如何查看项目中安装包的版本</h3><p>比如查看webpack的版本</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">npm</span> ls webpack</div></pre></td></tr></table></figure><p>npm-check-updates 是一个工具，它使用所有依赖项的最新版本自动调整 package.json</p><p>(参见)[<a href="https://www.npmjs.org/package/npm-check-updates">https://www.npmjs.org/package/npm-check-updates</a> web]</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">npm</span> install -g <span class="built_in">npm</span>-check-updates</div><div class="line">$ <span class="built_in">npm</span>-check-updates -u</div></pre></td></tr></table></figure><p>这个时候就会出现下面的版本升级的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">react-redux                    ^4.4.6  →   ^5.0.5</div><div class="line">react-router                   ^3.0.0  →   ^4.1.2</div><div class="line">redux-logger                   ^2.7.4  →   ^3.0.6</div><div class="line">babel-eslint                   ^6.0.0  →   ^7.2.3</div><div class="line">babel-loader                   ^6.2.4  →   ^7.1.1</div><div class="line">copy-webpack-plugin            ^1.1.1  →   ^4.0.1</div><div class="line">cross-env                      ^3.1.3  →   ^5.0.1</div><div class="line">css-loader                    ^0.23.1  →  ^0.28.4</div><div class="line">eslint                         ^2.8.0  →   ^4.3.0</div><div class="line">eslint-config-airbnb           ^8.0.0  →  ^15.1.0</div><div class="line">eslint-plugin-react            ^4.2.3  →   ^7.1.0</div><div class="line">event-source-polyfill           0.0.7  →    0.0.9</div><div class="line">extract-text-webpack-plugin    ^1.0.1  →   ^3.0.0</div><div class="line">file-loader                    ^0.8.5  →  ^0.11.2</div><div class="line">html-loader                    ^0.4.4  →   ^0.5.0</div><div class="line">jsdom                          ^8.2.0  →  ^11.1.0</div><div class="line">less-loader                    ^2.2.2  →   ^4.0.5</div><div class="line">mocha                          ^2.4.5  →   ^3.4.2</div><div class="line">node-sass                      ^3.7.0  →   ^4.5.3</div><div class="line">open-browser-webpack-plugin     0.0.2  →    0.0.5</div><div class="line">sass-loader                    ^4.0.0  →   ^6.0.6</div><div class="line">style-loader                  ^0.13.0  →  ^0.18.2</div><div class="line">webpack                      ^1.12.14  →   ^3.4.1</div><div class="line">webpack-dev-server            ^1.14.1  →   ^2.6.1</div></pre></td></tr></table></figure><p>然后再安装新的版本如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何查看项目中安装包的版本&quot;&gt;&lt;a href=&quot;#如何查看项目中安装包的版本&quot; class=&quot;headerlink&quot; title=&quot;如何查看项目中安装包的版本&quot;&gt;&lt;/a&gt;如何查看项目中安装包的版本&lt;/h3&gt;&lt;p&gt;比如查看webpack的版本&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何升级自己的项目相关包的依赖</title>
    <link href="http://yoursite.com/2017/07/27/Npm/%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2017/07/27/Npm/如何升级自己的项目/</id>
    <published>2017-07-27T06:40:25.000Z</published>
    <updated>2017-09-10T16:42:35.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何查看项目中安装包的版本"><a href="#如何查看项目中安装包的版本" class="headerlink" title="如何查看项目中安装包的版本"></a>如何查看项目中安装包的版本</h3><p>比如查看webpack的版本</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">npm</span> ls webpack</div></pre></td></tr></table></figure><p>npm-check-updates 是一个工具，它使用所有依赖项的最新版本自动调整 package.json</p><p>(参见)[<a href="https://www.npmjs.org/package/npm-check-updates">https://www.npmjs.org/package/npm-check-updates</a> web]</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">npm</span> install -g <span class="built_in">npm</span>-check-updates</div><div class="line">$ <span class="built_in">npm</span>-check-updates -u</div></pre></td></tr></table></figure><p>这个时候就会出现下面的版本升级的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">react-redux                    ^4.4.6  →   ^5.0.5</div><div class="line">react-router                   ^3.0.0  →   ^4.1.2</div><div class="line">redux-logger                   ^2.7.4  →   ^3.0.6</div><div class="line">babel-eslint                   ^6.0.0  →   ^7.2.3</div><div class="line">babel-loader                   ^6.2.4  →   ^7.1.1</div><div class="line">copy-webpack-plugin            ^1.1.1  →   ^4.0.1</div><div class="line">cross-env                      ^3.1.3  →   ^5.0.1</div><div class="line">css-loader                    ^0.23.1  →  ^0.28.4</div><div class="line">eslint                         ^2.8.0  →   ^4.3.0</div><div class="line">eslint-config-airbnb           ^8.0.0  →  ^15.1.0</div><div class="line">eslint-plugin-react            ^4.2.3  →   ^7.1.0</div><div class="line">event-source-polyfill           0.0.7  →    0.0.9</div><div class="line">extract-text-webpack-plugin    ^1.0.1  →   ^3.0.0</div><div class="line">file-loader                    ^0.8.5  →  ^0.11.2</div><div class="line">html-loader                    ^0.4.4  →   ^0.5.0</div><div class="line">jsdom                          ^8.2.0  →  ^11.1.0</div><div class="line">less-loader                    ^2.2.2  →   ^4.0.5</div><div class="line">mocha                          ^2.4.5  →   ^3.4.2</div><div class="line">node-sass                      ^3.7.0  →   ^4.5.3</div><div class="line">open-browser-webpack-plugin     0.0.2  →    0.0.5</div><div class="line">sass-loader                    ^4.0.0  →   ^6.0.6</div><div class="line">style-loader                  ^0.13.0  →  ^0.18.2</div><div class="line">webpack                      ^1.12.14  →   ^3.4.1</div><div class="line">webpack-dev-server            ^1.14.1  →   ^2.6.1</div></pre></td></tr></table></figure><p>然后再安装新的版本如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何查看项目中安装包的版本&quot;&gt;&lt;a href=&quot;#如何查看项目中安装包的版本&quot; class=&quot;headerlink&quot; title=&quot;如何查看项目中安装包的版本&quot;&gt;&lt;/a&gt;如何查看项目中安装包的版本&lt;/h3&gt;&lt;p&gt;比如查看webpack的版本&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node基础</title>
    <link href="http://yoursite.com/2017/07/02/Node/node%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2017/07/02/Node/node基础/</id>
    <published>2017-07-02T12:22:57.000Z</published>
    <updated>2017-09-10T16:42:35.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node的优势"><a href="#node的优势" class="headerlink" title="node的优势"></a>node的优势</h1><ol><li>性能高</li><li>和前端的js配合很方便</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;node的优势&quot;&gt;&lt;a href=&quot;#node的优势&quot; class=&quot;headerlink&quot; title=&quot;node的优势&quot;&gt;&lt;/a&gt;node的优势&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;性能高&lt;/li&gt;
&lt;li&gt;和前端的js配合很方便&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>react学习</title>
    <link href="http://yoursite.com/2017/06/29/React/react%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/06/29/React/react学习/</id>
    <published>2017-06-29T08:13:56.000Z</published>
    <updated>2017-11-27T13:52:31.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react网站"><a href="#react网站" class="headerlink" title="react网站"></a>react网站</h2><p><a href="https://github.com/airbnb/javascript/tree/master/react">关于开发规范</a></p><h2 id="全栈工程师"><a href="#全栈工程师" class="headerlink" title="全栈工程师"></a>全栈工程师</h2><p>技术栈：两种类型<br>mongodb express react node redux webpack<br>MongoDB+Express+Angular+Node</p><p>但是如果要成为一个全战工程师，还需要多看有关后台的东西，比如 Python</p><p><a href="https://zhuanlan.zhihu.com/p/23527988">react的学习资源</a></p><p>学习react还需要学习：  flux, Immutable.js, 学习服务端渲染</p><h2 id="属性的验证"><a href="#属性的验证" class="headerlink" title="属性的验证"></a>属性的验证</h2><p>propTypes 存在在prop－types包中，在react 15.4 被从react包中移到一个独立到包中，它的作用是在react开发阶段提供对传入组件的属性进行类型验证</p><h2 id="react组件的性能调优的问题"><a href="#react组件的性能调优的问题" class="headerlink" title="react组件的性能调优的问题"></a>react组件的性能调优的问题</h2><ol><li>父组件更新默认触发所有子组件更新</li><li>列表类型的组件默认更新方式非常复杂</li></ol><p>React性能检测工具</p><p>我们利用 <code>react-addons-perf</code> 进行性能检测。引入方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Perf <span class="keyword">from</span> <span class="string">'react-addons-perf'</span></div><div class="line"><span class="built_in">window</span>.Perf = Perf <span class="comment">// 挂载到全局变量方便使用</span></div></pre></td></tr></table></figure><p>检测方法，在浏览器控制台输入如下命令：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">开始记录：<span class="selector-tag">Perf</span><span class="selector-class">.start</span>()</div><div class="line">结束记录：<span class="selector-tag">Perf</span><span class="selector-class">.stop</span>()</div><div class="line">打印结果：<span class="selector-tag">printInclusive</span>()</div></pre></td></tr></table></figure><p>注: 生产环境不要引入perf</p><h2 id="React-性能优化原理"><a href="#React-性能优化原理" class="headerlink" title="React 性能优化原理"></a>React 性能优化原理</h2><p>这是React官网对组件渲染机制的描述图，其中绿色组件代表不需要更新，红色组件需要更新，影响更新的条件主要有SCU(shouldComponentUpdate)及DOM diff结果。<a href="http://react-china.org/t/react/11562">访问的来源</a></p><h2 id="如何更好的学习"><a href="#如何更好的学习" class="headerlink" title="如何更好的学习"></a>如何更好的学习</h2><p>这个东西是干嘛的？ 这个问题其实很简单，在引入任何工具之前，一定要搞清楚它是干嘛的，核心功能是什么，这样才能确保在项目中正确地使用并收获预期的收益。</p><p>它解决了什么问题？ 我认为，任何工具的引入都应该解决了现阶段的开发痛点，比如 Vue 可以帮助你通过数据来驱动页面、Babel 能帮你享受 ES6 带来的语法糖。如果引入一个工具没有帮你解决开发过程中的任何痛点，那你应该仔细考虑一下是否真的需要它。</p><p>我为什么需要它？ 这个问题其实是前两个问题的综合命题，即引入任何工具都应该是带有一定目的性的，就好像我想在项目中使用 ES6 语法，所以我引入了 Babel，如果它达不到你的预期目的，那么你并不一定真的需要它。</p><p>怎么把知识转换为生产力？<br>基础的东西就那么多，把东西用活，变着花样地弥补不足才是王道。</p><p>前端是还需要软知识的：<br>和他人沟通的能力，这点事一定要有的<br>我不会变成是我可以学<br>遇到问题不是立刻问， 而是自己先思考解决的办法</p><h2 id="这是对技术程序员的建议"><a href="#这是对技术程序员的建议" class="headerlink" title="这是对技术程序员的建议"></a>这是对技术程序员的建议</h2><p>在技术上更应该注重扎实的基础，把对工具的应用当成提升效率的方法。<br>在技术之外更应该注重自身情商、解决问题、独立思考以及自主学习的能力的培养。<br>当然，还有最最最重要的一点是：一定要有一个好身体，多运动少熬夜，打铁还需自身硬啊。</p><h2 id="收集的资料包"><a href="#收集的资料包" class="headerlink" title="收集的资料包"></a>收集的资料包</h2><p>一只迷途的前端小码农，徜徉在计算机的世界，渴望成为一名有点点厉害的全栈开发工程师</p><ul><li><a href="https://github.com/qianlongo">GitHub</a></li><li><a href="https://qianlongo.github.io/">我的文章</a></li></ul><p><a href="http://blog.csdn.net/awaw00/article/category/6692955">React全家桶入门系列文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;react网站&quot;&gt;&lt;a href=&quot;#react网站&quot; class=&quot;headerlink&quot; title=&quot;react网站&quot;&gt;&lt;/a&gt;react网站&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/airbnb/javascript/tree
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
</feed>
